<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Off-Axis Projection - Glassmorphism</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #video {
            position: absolute;
            top: 44px;
            right: 20px;
            width: 180px;
            height: 135px;
            border-radius: 20px;
            transform: scaleX(-1);
            z-index: 10;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        #status {
            position: absolute;
            top: 44px;
            left: 20px;
            color: white;
            font-size: 13px;
            backdrop-filter: blur(16px) saturate(180%);
            background: rgba(255, 255, 255, 0.15);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 10;
            font-weight: 500;
            line-height: 1.6;
        }
        #calibrate {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 32px;
            backdrop-filter: blur(16px) saturate(180%);
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        #calibrate:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateX(-50%) scale(1.05);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <video id="video" autoplay playsinline></video>
        <div id="status">Initializing...</div>
        <button id="calibrate">‚ú® Calibrate</button>
    </div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/face_detection.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';

    const canvas = document.getElementById('canvas');
    const video = document.getElementById('video');
    const status = document.getElementById('status');
    const calibrateBtn = document.getElementById('calibrate');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);

    // Shader materials
    const glassShader = {
        uniforms: {
            time: { value: 0 },
            color1: { value: new THREE.Color(0x667eea) },
            color2: { value: new THREE.Color(0x764ba2) }
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float time;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                
                vec3 pos = position;
                pos += normal * sin(position.y * 2.0 + time) * 0.1;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 3.0);
                vec3 color = mix(color1, color2, fresnel);
                
                float glow = fresnel * 0.8 + 0.2;
                color *= glow;
                
                float alpha = 0.6 + fresnel * 0.4;
                gl_FragColor = vec4(color, alpha);
            }
        `
    };

    const liquidShader = {
        uniforms: {
            time: { value: 0 }
        },
        vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            uniform float time;
            
            void main() {
                vPosition = position;
                vNormal = normalize(normalMatrix * normal);
                
                vec3 pos = position;
                float wave = sin(pos.x * 3.0 + time) * cos(pos.z * 3.0 + time) * 0.2;
                pos.y += wave;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
                vec3 color = vec3(0.4, 0.6, 1.0);
                
                float pattern = sin(vPosition.x * 10.0 + time) * cos(vPosition.z * 10.0 + time);
                pattern = pattern * 0.5 + 0.5;
                
                color = mix(color, vec3(1.0, 0.4, 0.8), pattern * 0.3);
                
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
                color += fresnel * vec3(0.8, 1.0, 1.0) * 0.5;
                
                gl_FragColor = vec4(color, 0.7);
            }
        `
    };

    const energyShader = {
        uniforms: {
            time: { value: 0 }
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            
            void main() {
                vUv = uv;
                vPosition = position;
                
                vec3 pos = position;
                float expansion = sin(time * 2.0) * 0.1 + 1.0;
                pos *= expansion;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vec2 uv = vUv;
                
                float noise = sin(uv.x * 20.0 + time) * cos(uv.y * 20.0 + time);
                noise += sin(uv.x * 10.0 - time * 2.0) * cos(uv.y * 15.0 + time);
                noise = noise * 0.5 + 0.5;
                
                vec3 color = vec3(0.0);
                color.r = sin(noise * 3.14159 + time) * 0.5 + 0.5;
                color.g = cos(noise * 3.14159 + time * 0.7) * 0.5 + 0.5;
                color.b = sin(noise * 3.14159 + time * 1.3) * 0.5 + 0.5;
                
                color *= 1.5;
                
                gl_FragColor = vec4(color, 0.8);
            }
        `
    };

    // Create objects with shaders
    function createScene() {
        // Central glass torus
        const torusGeom = new THREE.TorusGeometry(2, 0.8, 32, 100);
        const torusMat = new THREE.ShaderMaterial({
            ...glassShader,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const torus = new THREE.Mesh(torusGeom, torusMat);
        torus.position.set(0, 0, -8);
        torus.userData.type = 'glass';
        scene.add(torus);

        // Liquid spheres
        for (let i = 0; i < 6; i++) {
            const sphereGeom = new THREE.IcosahedronGeometry(0.8, 4);
            const sphereMat = new THREE.ShaderMaterial({
                ...liquidShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            
            const angle = (i / 6) * Math.PI * 2;
            sphere.position.set(
                Math.cos(angle) * 5,
                Math.sin(i * 0.5) * 2,
                Math.sin(angle) * 5 - 8
            );
            sphere.userData.type = 'liquid';
            sphere.userData.angle = angle;
            sphere.userData.index = i;
            scene.add(sphere);
        }

        // Energy cubes
        for (let i = 0; i < 4; i++) {
            const cubeGeom = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const cubeMat = new THREE.ShaderMaterial({
                ...energyShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            
            cube.position.set(
                (i % 2) * 6 - 3,
                Math.floor(i / 2) * 4 - 2,
                -6
            );
            cube.userData.type = 'energy';
            scene.add(cube);
        }

        // Background particles
        const particleCount = 100;
        const particleGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 30;
            positions[i + 1] = (Math.random() - 0.5) * 30;
            positions[i + 2] = (Math.random() - 0.5) * 20 - 10;
        }
        
        particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const particleMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeom, particleMat);
        scene.add(particles);
    }

    createScene();

    let headX = 0, headY = 0, headZ = 50;
    let smoothX = 0, smoothY = 0, smoothZ = 50;
    let baseDistance = 50;
    let faceDetected = false;
    let stableFrames = 0;
    let autoCalibrated = false;
    const screenWidthCm = 40, screenHeightCm = 25;
    const smoothFactor = 0.15;
    const maxOffset = 15;

    function updateCameraProjection() {
        // Smooth interpolation
        smoothX += (headX - smoothX) * smoothFactor;
        smoothY += (headY - smoothY) * smoothFactor;
        smoothZ += (headZ - smoothZ) * smoothFactor;

        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã X (–ª–µ–≤–æ-–ø—Ä–∞–≤–æ) –∏ Z (–ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ-–æ—Ç–¥–∞–ª–µ–Ω–∏–µ)
        const eyeX = -(smoothX / window.innerWidth - 0.5) * screenWidthCm;  // –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω X
        const eyeY = -(smoothY / window.innerHeight - 0.5) * screenHeightCm;
        const eyeZ = baseDistance / smoothZ * 50;  // –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω Z

        // Clamp eye position to prevent extreme angles
        const clampedX = Math.max(-maxOffset, Math.min(maxOffset, eyeX));
        const clampedY = Math.max(-maxOffset, Math.min(maxOffset, eyeY));

        const near = 0.1, far = 1000;
        const left = -screenWidthCm / 2 - clampedX;
        const right = screenWidthCm / 2 - clampedX;
        const bottom = -screenHeightCm / 2 - clampedY;
        const top = screenHeightCm / 2 - clampedY;
        const scale = near / eyeZ;

        camera.projectionMatrix.makePerspective(
            left * scale, right * scale, top * scale, bottom * scale, near, far
        );

        camera.position.set(clampedX * 0.1, clampedY * 0.1, eyeZ * 0.1);
        camera.lookAt(0, 0, -8);
    }

    const faceDetection = new FaceDetection({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/${file}`
    });

    faceDetection.setOptions({
        model: 'short',
        minDetectionConfidence: 0.5
    });

    faceDetection.onResults((results) => {
        if (results.detections && results.detections.length > 0) {
            const detection = results.detections[0];
            const bbox = detection.boundingBox;
            
            headX = bbox.xCenter * window.innerWidth;
            headY = bbox.yCenter * window.innerHeight;
            const faceWidth = bbox.width * window.innerWidth;
            headZ = baseDistance * (100 / faceWidth);
            headZ = Math.max(20, Math.min(headZ, 100));
            
            faceDetected = true;
            
            // Auto-calibration after 60 stable frames (~2 seconds)
            if (!autoCalibrated) {
                stableFrames++;
                if (stableFrames > 60) {
                    baseDistance = headZ;
                    autoCalibrated = true;
                    status.innerHTML = `‚úÖ Auto-calibrated!<br>Position: ${headX.toFixed(0)}px, ${headY.toFixed(0)}px<br>Distance: ${headZ.toFixed(0)}cm`;
                    setTimeout(() => {
                        if (faceDetected) {
                            status.innerHTML = `üëÅÔ∏è Face tracked<br>Position: ${headX.toFixed(0)}px, ${headY.toFixed(0)}px<br>Distance: ${headZ.toFixed(0)}cm`;
                        }
                    }, 2000);
                } else {
                    status.innerHTML = `‚è≥ Calibrating... ${Math.floor((60 - stableFrames) / 30)}s`;
                }
            } else {
                status.innerHTML = `üëÅÔ∏è Face tracked<br>Position: ${headX.toFixed(0)}px, ${headY.toFixed(0)}px<br>Distance: ${headZ.toFixed(0)}cm`;
            }
        } else {
            faceDetected = false;
            stableFrames = 0;
            status.innerHTML = 'üëÄ Looking for face...';
        }
    });

    const cameraUtils = new Camera(video, {
        onFrame: async () => {
            await faceDetection.send({ image: video });
        },
        width: 640,
        height: 480
    });

    cameraUtils.start().catch(err => {
        status.innerHTML = '‚ö†Ô∏è Camera error: ' + err.message;
    });

    calibrateBtn.addEventListener('click', () => {
        if (faceDetected) {
            baseDistance = headZ;
            autoCalibrated = true;
            stableFrames = 0;
            status.innerHTML = '‚úÖ Manual calibration!<br>' + status.innerHTML.split('<br>').slice(1).join('<br>');
        }
    });

    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.016;
        
        if (faceDetected) {
            updateCameraProjection();
        }
        
        scene.children.forEach(child => {
            if (child instanceof THREE.Mesh) {
                if (child.userData.type === 'glass') {
                    child.rotation.x += 0.003;
                    child.rotation.y += 0.005;
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'liquid') {
                    const i = child.userData.index;
                    child.rotation.y += 0.01;
                    child.position.y = Math.sin(time + i) * 2;
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'energy') {
                    child.rotation.x += 0.01;
                    child.rotation.y += 0.015;
                    child.material.uniforms.time.value = time;
                }
            }
        });
        
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>
