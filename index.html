<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reactive Glassmorphism Portal</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #video {
            position: absolute;
            top: 44px;
            right: 20px;
            width: 180px;
            height: 135px;
            border-radius: 20px;
            transform: scaleX(-1);
            z-index: 10;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s;
        }
        #status {
            position: absolute;
            top: 44px;
            left: 20px;
            color: white;
            font-size: 13px;
            backdrop-filter: blur(16px) saturate(180%);
            background: rgba(255, 255, 255, 0.15);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 10;
            font-weight: 500;
            line-height: 1.6;
        }
        #calibrate {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 32px;
            backdrop-filter: blur(16px) saturate(180%);
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        #calibrate:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateX(-50%) scale(1.05);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <video id="video" autoplay playsinline></video>
        <div id="status">Initializing...</div>
        <button id="calibrate">‚ú® Calibrate</button>
    </div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/face_detection.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';

    const canvas = document.getElementById('canvas');
    const video = document.getElementById('video');
    const status = document.getElementById('status');
    const calibrateBtn = document.getElementById('calibrate');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);

    // Enhanced shaders with proximity reactions
    const glassShader = {
        uniforms: {
            time: { value: 0 },
            proximity: { value: 0 },
            color1: { value: new THREE.Color(0x667eea) },
            color2: { value: new THREE.Color(0x764ba2) }
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float time;
            uniform float proximity;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                
                vec3 pos = position;
                float wave = sin(position.y * 2.0 + time) * 0.1;
                wave += sin(position.x * 3.0 + time * 0.7) * 0.05;
                pos += normal * wave * (1.0 + proximity * 0.5);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float proximity;
            uniform vec3 color1;
            uniform vec3 color2;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 3.0);
                vec3 color = mix(color1, color2, fresnel);
                
                // Pulse with proximity
                float pulse = sin(time * 2.0) * 0.5 + 0.5;
                color += vec3(0.3, 0.5, 0.8) * proximity * pulse;
                
                float glow = fresnel * 0.8 + 0.2 + proximity * 0.3;
                color *= glow;
                
                float alpha = 0.6 + fresnel * 0.4 + proximity * 0.2;
                gl_FragColor = vec4(color, alpha);
            }
        `
    };

    const liquidShader = {
        uniforms: {
            time: { value: 0 },
            proximity: { value: 0 }
        },
        vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            uniform float time;
            uniform float proximity;
            
            void main() {
                vPosition = position;
                vNormal = normalize(normalMatrix * normal);
                
                vec3 pos = position;
                float wave = sin(pos.x * 3.0 + time) * cos(pos.z * 3.0 + time) * 0.2;
                wave *= (1.0 + proximity * 0.8);
                pos.y += wave;
                
                // Expand when close
                pos *= (1.0 + proximity * 0.15);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float proximity;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
                vec3 color = vec3(0.4, 0.6, 1.0);
                
                float pattern = sin(vPosition.x * 10.0 + time) * cos(vPosition.z * 10.0 + time);
                pattern = pattern * 0.5 + 0.5;
                
                color = mix(color, vec3(1.0, 0.4, 0.8), pattern * 0.3);
                
                // React to proximity
                color += vec3(0.5, 0.8, 1.0) * proximity * 0.4;
                
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
                color += fresnel * vec3(0.8, 1.0, 1.0) * 0.5;
                
                gl_FragColor = vec4(color, 0.7 + proximity * 0.2);
            }
        `
    };

    const energyShader = {
        uniforms: {
            time: { value: 0 },
            proximity: { value: 0 }
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            uniform float proximity;
            
            void main() {
                vUv = uv;
                vPosition = position;
                
                vec3 pos = position;
                float expansion = sin(time * 2.0 + proximity * 3.0) * 0.1 + 1.0;
                expansion += proximity * 0.3;
                pos *= expansion;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float proximity;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vec2 uv = vUv;
                
                float speed = 1.0 + proximity * 2.0;
                float noise = sin(uv.x * 20.0 + time * speed) * cos(uv.y * 20.0 + time * speed);
                noise += sin(uv.x * 10.0 - time * 2.0 * speed) * cos(uv.y * 15.0 + time * speed);
                noise = noise * 0.5 + 0.5;
                
                vec3 color = vec3(0.0);
                color.r = sin(noise * 3.14159 + time) * 0.5 + 0.5;
                color.g = cos(noise * 3.14159 + time * 0.7) * 0.5 + 0.5;
                color.b = sin(noise * 3.14159 + time * 1.3) * 0.5 + 0.5;
                
                color *= (1.5 + proximity * 0.8);
                
                gl_FragColor = vec4(color, 0.8 + proximity * 0.15);
            }
        `
    };

    const objects = [];

    function createScene() {
        // Central glass torus
        const torusGeom = new THREE.TorusGeometry(2, 0.8, 32, 100);
        const torusMat = new THREE.ShaderMaterial({
            ...glassShader,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const torus = new THREE.Mesh(torusGeom, torusMat);
        torus.position.set(0, 0, -8);
        torus.userData.type = 'glass';
        torus.userData.basePos = torus.position.clone();
        objects.push(torus);
        scene.add(torus);

        // Liquid spheres
        for (let i = 0; i < 6; i++) {
            const sphereGeom = new THREE.IcosahedronGeometry(0.8, 4);
            const sphereMat = new THREE.ShaderMaterial({
                ...liquidShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            
            const angle = (i / 6) * Math.PI * 2;
            sphere.position.set(
                Math.cos(angle) * 5,
                Math.sin(i * 0.5) * 2,
                Math.sin(angle) * 5 - 8
            );
            sphere.userData.type = 'liquid';
            sphere.userData.angle = angle;
            sphere.userData.index = i;
            sphere.userData.basePos = sphere.position.clone();
            objects.push(sphere);
            scene.add(sphere);
        }

        // Energy cubes
        for (let i = 0; i < 4; i++) {
            const cubeGeom = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const cubeMat = new THREE.ShaderMaterial({
                ...energyShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            
            cube.position.set(
                (i % 2) * 6 - 3,
                Math.floor(i / 2) * 4 - 2,
                -6
            );
            cube.userData.type = 'energy';
            cube.userData.basePos = cube.position.clone();
            objects.push(cube);
            scene.add(cube);
        }

        // Background particles
        const particleCount = 150;
        const particleGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 40;
            positions[i + 1] = (Math.random() - 0.5) * 40;
            positions[i + 2] = (Math.random() - 0.5) * 30 - 10;
        }
        
        particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const particleMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.15,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeom, particleMat);
        scene.add(particles);
    }

    createScene();

    let headX = 0, headY = 0, headZ = 50;
    let smoothX = 0, smoothY = 0, smoothZ = 50;
    let calibratedX = 0, calibratedY = 0, calibratedZ = 50;
    let faceDetected = false;
    let stableFrames = 0;
    let autoCalibrated = false;
    const smoothFactor = 0.12;

    let camPosX = 0, camPosY = 0, camPosZ = 0;
    let smoothCamX = 0, smoothCamY = 0, smoothCamZ = 0;
    let proximityValue = 0;

    function updateCameraProjection() {
        smoothX += (headX - smoothX) * smoothFactor;
        smoothY += (headY - smoothY) * smoothFactor;
        smoothZ += (headZ - smoothZ) * smoothFactor;

        const deltaX = smoothX - calibratedX;
        const deltaY = smoothY - calibratedY;
        const deltaZ = smoothZ - calibratedZ;

        camPosX = -(deltaX / window.innerWidth) * 20;
        camPosY = (deltaY / window.innerHeight) * 15;
        camPosZ = (deltaZ / calibratedZ) * 15;

        // Calculate proximity (0 to 1, closer = higher)
        const normalizedZ = Math.max(0, Math.min(1, (calibratedZ - smoothZ) / calibratedZ + 0.5));
        proximityValue += (normalizedZ - proximityValue) * 0.1;

        smoothCamX += (camPosX - smoothCamX) * smoothFactor;
        smoothCamY += (camPosY - smoothCamY) * smoothFactor;
        smoothCamZ += (camPosZ - smoothCamZ) * smoothFactor;

        camera.position.set(smoothCamX, smoothCamY, smoothCamZ);
        camera.lookAt(0, 0, -8);

        // Update all object shaders with proximity
        objects.forEach(obj => {
            if (obj.material.uniforms.proximity) {
                obj.material.uniforms.proximity.value = proximityValue;
            }
            
            // Objects react to camera approach
            if (obj.userData.type === 'liquid') {
                const pushBack = proximityValue * 2;
                obj.position.z = obj.userData.basePos.z - pushBack;
            }
        });

        const eyeX = smoothCamX * 0.5;
        const eyeY = smoothCamY * 0.5;
        
        const screenWidthCm = 40, screenHeightCm = 25;
        const near = 0.1, far = 1000;
        const eyeDist = 5;
        
        const left = -screenWidthCm / 2 - eyeX;
        const right = screenWidthCm / 2 - eyeX;
        const bottom = -screenHeightCm / 2 - eyeY;
        const top = screenHeightCm / 2 - eyeY;
        const scale = near / eyeDist;

        camera.projectionMatrix.makePerspective(
            left * scale, right * scale, top * scale, bottom * scale, near, far
        );
    }

    const faceDetection = new FaceDetection({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection@0.4/${file}`
    });

    faceDetection.setOptions({
        model: 'short',
        minDetectionConfidence: 0.5
    });

    faceDetection.onResults((results) => {
        if (results.detections && results.detections.length > 0) {
            const detection = results.detections[0];
            const bbox = detection.boundingBox;
            
            headX = bbox.xCenter * window.innerWidth;
            headY = bbox.yCenter * window.innerHeight;
            const faceWidth = bbox.width * window.innerWidth;
            headZ = 50 * (100 / faceWidth);
            headZ = Math.max(20, Math.min(headZ, 100));
            
            faceDetected = true;
            
            if (!autoCalibrated) {
                stableFrames++;
                if (stableFrames > 60) {
                    calibratedX = headX;
                    calibratedY = headY;
                    calibratedZ = headZ;
                    autoCalibrated = true;
                    status.innerHTML = `‚úÖ Portal open<br>Distance: ${headZ.toFixed(0)}cm`;
                    setTimeout(() => {
                        if (faceDetected) {
                            status.innerHTML = `üåÄ Resonating<br>Proximity: ${(proximityValue * 100).toFixed(0)}%`;
                        }
                    }, 2000);
                } else {
                    status.innerHTML = `‚è≥ Attuning... ${Math.floor((60 - stableFrames) / 30)}s`;
                }
            } else {
                status.innerHTML = `üåÄ Resonating<br>Proximity: ${(proximityValue * 100).toFixed(0)}%`;
            }
        } else {
            faceDetected = false;
            stableFrames = 0;
            status.innerHTML = 'üëÅÔ∏è Seeking presence...';
        }
    });

    const cameraUtils = new Camera(video, {
        onFrame: async () => {
            await faceDetection.send({ image: video });
        },
        width: 640,
        height: 480
    });

    cameraUtils.start().catch(err => {
        status.innerHTML = '‚ö†Ô∏è Portal blocked: ' + err.message;
    });

    calibrateBtn.addEventListener('click', () => {
        if (faceDetected) {
            calibratedX = headX;
            calibratedY = headY;
            calibratedZ = headZ;
            autoCalibrated = true;
            stableFrames = 0;
            smoothCamX = 0;
            smoothCamY = 0;
            smoothCamZ = 0;
            status.innerHTML = '‚úÖ Recalibrated<br>Portal realigned';
        }
    });

    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.016;
        
        if (faceDetected && autoCalibrated) {
            updateCameraProjection();
        }
        
        scene.children.forEach(child => {
            if (child instanceof THREE.Mesh) {
                if (child.userData.type === 'glass') {
                    child.rotation.x += 0.003;
                    child.rotation.y += 0.005;
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'liquid') {
                    const i = child.userData.index;
                    child.rotation.y += 0.01 * (1 + proximityValue * 0.5);
                    child.position.y = child.userData.basePos.y + Math.sin(time + i) * 2;
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'energy') {
                    child.rotation.x += 0.01 * (1 + proximityValue);
                    child.rotation.y += 0.015 * (1 + proximityValue);
                    child.material.uniforms.time.value = time;
                }
            }
        });
        
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>
