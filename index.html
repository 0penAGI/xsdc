<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal Gaze - Living System</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #video {
            position: absolute;
            top: 44px;
            right: 20px;
            width: 180px;
            height: 135px;
            border-radius: 20px;
            transform: scaleX(-1);
            z-index: 10;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        #status {
            position: absolute;
            top: 44px;
            left: 20px;
            color: white;
            font-size: 13px;
            backdrop-filter: blur(16px) saturate(180%);
            background: rgba(255, 255, 255, 0.15);
            padding: 16px 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            z-index: 10;
            font-weight: 500;
            line-height: 1.6;
        }
        #calibrate {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 32px;
            backdrop-filter: blur(16px) saturate(180%);
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            font-size: 15px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        #calibrate:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateX(-50%) scale(1.05);
        }
        #reticle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #reticle.active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.5);
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <video id="video" autoplay playsinline></video>
        <div id="reticle"></div>
        <div id="status">Initializing portal...</div>
        <button id="calibrate">‚ú® Attune</button>
    </div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';

    const canvas = document.getElementById('canvas');
    const video = document.getElementById('video');
    const status = document.getElementById('status');
    const calibrateBtn = document.getElementById('calibrate');
    const reticle = document.getElementById('reticle');

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);

    const raycaster = new THREE.Raycaster();
    const gazePoint = new THREE.Vector2();

    // Enhanced shaders with gaze reaction
    const glassShader = {
        uniforms: {
            time: { value: 0 },
            proximity: { value: 0 },
            gazeIntensity: { value: 0 },
            color1: { value: new THREE.Color(0x667eea) },
            color2: { value: new THREE.Color(0x764ba2) }
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPos;
            uniform float time;
            uniform float proximity;
            uniform float gazeIntensity;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                
                vec3 pos = position;
                float wave = sin(position.y * 2.0 + time) * 0.1;
                wave += sin(position.x * 3.0 + time * 0.7) * 0.05;
                pos += normal * wave * (1.0 + proximity * 0.5 + gazeIntensity * 0.3);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float proximity;
            uniform float gazeIntensity;
            uniform vec3 color1;
            uniform vec3 color2;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPos;
            
            void main() {
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 3.0);
                vec3 color = mix(color1, color2, fresnel);
                
                float pulse = sin(time * 2.0) * 0.5 + 0.5;
                color += vec3(0.3, 0.5, 0.8) * proximity * pulse;
                color += vec3(1.0, 0.8, 0.3) * gazeIntensity * 0.6;
                
                float glow = fresnel * 0.8 + 0.2 + proximity * 0.3 + gazeIntensity * 0.4;
                color *= glow;
                
                float alpha = 0.6 + fresnel * 0.4 + proximity * 0.2 + gazeIntensity * 0.3;
                gl_FragColor = vec4(color, alpha);
            }
        `
    };

    const liquidShader = {
        uniforms: {
            time: { value: 0 },
            proximity: { value: 0 },
            gazeIntensity: { value: 0 }
        },
        vertexShader: `
            varying vec3 vPosition;
            varying vec3 vNormal;
            uniform float time;
            uniform float proximity;
            uniform float gazeIntensity;
            
            void main() {
                vPosition = position;
                vNormal = normalize(normalMatrix * normal);
                
                vec3 pos = position;
                float wave = sin(pos.x * 3.0 + time) * cos(pos.z * 3.0 + time) * 0.2;
                wave *= (1.0 + proximity * 0.8 + gazeIntensity * 0.5);
                pos.y += wave;
                
                pos *= (1.0 + proximity * 0.15 + gazeIntensity * 0.2);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float proximity;
            uniform float gazeIntensity;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
                vec3 color = vec3(0.4, 0.6, 1.0);
                
                float pattern = sin(vPosition.x * 10.0 + time) * cos(vPosition.z * 10.0 + time);
                pattern = pattern * 0.5 + 0.5;
                
                color = mix(color, vec3(1.0, 0.4, 0.8), pattern * 0.3);
                color += vec3(0.5, 0.8, 1.0) * proximity * 0.4;
                color += vec3(1.0, 0.9, 0.5) * gazeIntensity * 0.7;
                
                float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
                color += fresnel * vec3(0.8, 1.0, 1.0) * 0.5;
                
                gl_FragColor = vec4(color, 0.7 + proximity * 0.2 + gazeIntensity * 0.2);
            }
        `
    };

    const energyShader = {
        uniforms: {
            time: { value: 0 },
            proximity: { value: 0 },
            gazeIntensity: { value: 0 }
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vPosition;
            uniform float time;
            uniform float proximity;
            uniform float gazeIntensity;
            
            void main() {
                vUv = uv;
                vPosition = position;
                
                vec3 pos = position;
                float expansion = sin(time * 2.0 + proximity * 3.0 + gazeIntensity * 5.0) * 0.1 + 1.0;
                expansion += proximity * 0.3 + gazeIntensity * 0.4;
                pos *= expansion;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform float time;
            uniform float proximity;
            uniform float gazeIntensity;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vec2 uv = vUv;
                
                float speed = 1.0 + proximity * 2.0 + gazeIntensity * 3.0;
                float noise = sin(uv.x * 20.0 + time * speed) * cos(uv.y * 20.0 + time * speed);
                noise += sin(uv.x * 10.0 - time * 2.0 * speed) * cos(uv.y * 15.0 + time * speed);
                noise = noise * 0.5 + 0.5;
                
                vec3 color = vec3(0.0);
                color.r = sin(noise * 3.14159 + time + gazeIntensity * 2.0) * 0.5 + 0.5;
                color.g = cos(noise * 3.14159 + time * 0.7 + gazeIntensity) * 0.5 + 0.5;
                color.b = sin(noise * 3.14159 + time * 1.3 + gazeIntensity * 3.0) * 0.5 + 0.5;
                
                color *= (1.5 + proximity * 0.8 + gazeIntensity * 1.2);
                
                gl_FragColor = vec4(color, 0.8 + proximity * 0.15 + gazeIntensity * 0.2);
            }
        `
    };

    const interactiveObjects = [];

    function createScene() {
        const torusGeom = new THREE.TorusGeometry(2, 0.8, 32, 100);
        const torusMat = new THREE.ShaderMaterial({
            ...glassShader,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const torus = new THREE.Mesh(torusGeom, torusMat);
        torus.position.set(0, 0, -8);
        torus.userData.type = 'glass';
        torus.userData.basePos = torus.position.clone();
        torus.userData.interactive = true;
        torus.userData.gazeTime = 0;
        interactiveObjects.push(torus);
        scene.add(torus);

        for (let i = 0; i < 6; i++) {
            const sphereGeom = new THREE.IcosahedronGeometry(0.8, 4);
            const sphereMat = new THREE.ShaderMaterial({
                ...liquidShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            
            const angle = (i / 6) * Math.PI * 2;
            sphere.position.set(
                Math.cos(angle) * 5,
                Math.sin(i * 0.5) * 2,
                Math.sin(angle) * 5 - 8
            );
            sphere.userData.type = 'liquid';
            sphere.userData.angle = angle;
            sphere.userData.index = i;
            sphere.userData.basePos = sphere.position.clone();
            sphere.userData.interactive = true;
            sphere.userData.gazeTime = 0;
            interactiveObjects.push(sphere);
            scene.add(sphere);
        }

        for (let i = 0; i < 4; i++) {
            const cubeGeom = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const cubeMat = new THREE.ShaderMaterial({
                ...energyShader,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const cube = new THREE.Mesh(cubeGeom, cubeMat);
            
            cube.position.set(
                (i % 2) * 6 - 3,
                Math.floor(i / 2) * 4 - 2,
                -6
            );
            cube.userData.type = 'energy';
            cube.userData.basePos = cube.position.clone();
            cube.userData.interactive = true;
            cube.userData.gazeTime = 0;
            interactiveObjects.push(cube);
            scene.add(cube);
        }

        const particleCount = 150;
        const particleGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 40;
            positions[i + 1] = (Math.random() - 0.5) * 40;
            positions[i + 2] = (Math.random() - 0.5) * 30 - 10;
        }
        
        particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const particleMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.15,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeom, particleMat);
        scene.add(particles);
    }

    createScene();

    let headX = 0, headY = 0, headZ = 50;
    let headPitch = 0, headYaw = 0, headRoll = 0;
    let smoothX = 0, smoothY = 0, smoothZ = 50;
    let smoothPitch = 0, smoothYaw = 0, smoothRoll = 0;
    let calibratedX = 0, calibratedY = 0, calibratedZ = 50;
    let calibratedPitch = 0, calibratedYaw = 0;
    let faceDetected = false;
    let stableFrames = 0;
    let autoCalibrated = false;
    const smoothFactor = 0.15;

    let camPosX = 0, camPosY = 0, camPosZ = 0;
    let smoothCamX = 0, smoothCamY = 0, smoothCamZ = 0;
    let proximityValue = 0;

    let gazedObject = null;

    function calculateHeadRotation(landmarks) {
        const noseTip = landmarks[1];
        const leftEye = landmarks[33];
        const rightEye = landmarks[263];
        const chin = landmarks[152];
        const forehead = landmarks[10];
        
        const eyeCenter = {
            x: (leftEye.x + rightEye.x) / 2,
            y: (leftEye.y + rightEye.y) / 2,
            z: (leftEye.z + rightEye.z) / 2
        };
        
        // Yaw (left-right rotation)
        const yaw = Math.atan2(noseTip.x - eyeCenter.x, noseTip.z - eyeCenter.z);
        
        // Pitch (up-down rotation)
        const pitch = Math.atan2(eyeCenter.y - noseTip.y, noseTip.z - eyeCenter.z);
        
        // Roll (tilt)
        const roll = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
        
        return { pitch, yaw, roll };
    }

    function updateCameraProjection() {
        smoothX += (headX - smoothX) * smoothFactor;
        smoothY += (headY - smoothY) * smoothFactor;
        smoothZ += (headZ - smoothZ) * smoothFactor;
        smoothPitch += (headPitch - smoothPitch) * smoothFactor;
        smoothYaw += (headYaw - smoothYaw) * smoothFactor;
        smoothRoll += (headRoll - smoothRoll) * smoothFactor;

        const deltaX = smoothX - calibratedX;
        const deltaY = smoothY - calibratedY;
        const deltaZ = smoothZ - calibratedZ;
        const deltaPitch = smoothPitch - calibratedPitch;
        const deltaYaw = smoothYaw - calibratedYaw;

        camPosX = -(deltaX / window.innerWidth) * 20;
        camPosY = (deltaY / window.innerHeight) * 15;
        camPosZ = (deltaZ / calibratedZ) * 15;

        const normalizedZ = Math.max(0, Math.min(1, (calibratedZ - smoothZ) / calibratedZ + 0.5));
        proximityValue += (normalizedZ - proximityValue) * 0.1;

        smoothCamX += (camPosX - smoothCamX) * smoothFactor;
        smoothCamY += (camPosY - smoothCamY) * smoothFactor;
        smoothCamZ += (camPosZ - smoothCamZ) * smoothFactor;

        camera.position.set(smoothCamX, smoothCamY, smoothCamZ);
        
        // Apply head rotation to camera
        camera.rotation.x = deltaPitch * 0.5;
        camera.rotation.y = deltaYaw * 0.8;
        camera.rotation.z = smoothRoll * 0.3;
        
        camera.lookAt(0, 0, -8);

        // Gaze detection
        gazePoint.x = deltaYaw * 2;
        gazePoint.y = -deltaPitch * 2;
        
        raycaster.setFromCamera(gazePoint, camera);
        const intersects = raycaster.intersectObjects(interactiveObjects);
        
        let anyGazed = false;
        interactiveObjects.forEach(obj => {
            const isGazed = intersects.length > 0 && intersects[0].object === obj;
            
            if (isGazed) {
                obj.userData.gazeTime += 0.016;
                gazedObject = obj;
                anyGazed = true;
            } else {
                obj.userData.gazeTime = Math.max(0, obj.userData.gazeTime - 0.032);
            }
            
            const gazeIntensity = Math.min(1, obj.userData.gazeTime / 1.0);
            
            if (obj.material.uniforms.gazeIntensity) {
                obj.material.uniforms.gazeIntensity.value = gazeIntensity;
            }
            if (obj.material.uniforms.proximity) {
                obj.material.uniforms.proximity.value = proximityValue;
            }
            
            if (obj.userData.type === 'liquid') {
                const pushBack = proximityValue * 2 + gazeIntensity * 1.5;
                obj.position.z = obj.userData.basePos.z - pushBack;
            }
        });
        
        // Update reticle
        if (anyGazed) {
            reticle.classList.add('active');
            const screenPos = intersects[0].point.clone().project(camera);
            reticle.style.left = ((screenPos.x + 1) / 2 * window.innerWidth) + 'px';
            reticle.style.top = ((1 - screenPos.y) / 2 * window.innerHeight) + 'px';
        } else {
            reticle.classList.remove('active');
            gazedObject = null;
        }

        const eyeX = smoothCamX * 0.5;
        const eyeY = smoothCamY * 0.5;
        
        const screenWidthCm = 40, screenHeightCm = 25;
        const near = 0.1, far = 1000;
        const eyeDist = 5;
        
        const left = -screenWidthCm / 2 - eyeX;
        const right = screenWidthCm / 2 - eyeX;
        const bottom = -screenHeightCm / 2 - eyeY;
        const top = screenHeightCm / 2 - eyeY;
        const scale = near / eyeDist;

        camera.projectionMatrix.makePerspective(
            left * scale, right * scale, top * scale, bottom * scale, near, far
        );
    }

    const faceMesh = new FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
    });

    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    faceMesh.onResults((results) => {
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];
            
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            const nose = landmarks[1];
            
            headX = ((leftEye.x + rightEye.x) / 2) * window.innerWidth;
            headY = ((leftEye.y + rightEye.y) / 2) * window.innerHeight;
            
            const eyeDistance = Math.sqrt(
                Math.pow((rightEye.x - leftEye.x) * window.innerWidth, 2) +
                Math.pow((rightEye.y - leftEye.y) * window.innerHeight, 2)
            );
            headZ = 50 * (65 / eyeDistance);
            headZ = Math.max(20, Math.min(headZ, 100));
            
            const rotation = calculateHeadRotation(landmarks);
            headPitch = rotation.pitch;
            headYaw = rotation.yaw;
            headRoll = rotation.roll;
            
            faceDetected = true;
            
            if (!autoCalibrated) {
                stableFrames++;
                if (stableFrames > 60) {
                    calibratedX = headX;
                    calibratedY = headY;
                    calibratedZ = headZ;
                    calibratedPitch = headPitch;
                    calibratedYaw = headYaw;
                    autoCalibrated = true;
                    status.innerHTML = `‚úÖ Portal attuned<br>Presence detected`;
                    setTimeout(() => {
                        if (faceDetected) {
                            status.innerHTML = `üåÄ Resonating<br>Look at objects`;
                        }
                    }, 2000);
                } else {
                    status.innerHTML = `‚è≥ Attuning... ${Math.ceil((60 - stableFrames) / 30)}s`;
                }
            } else {
                let statusText = `üåÄ Proximity: ${(proximityValue * 100).toFixed(0)}%`;
                if (gazedObject) {
                    statusText += `<br>üëÅÔ∏è Gazing: ${gazedObject.userData.type}`;
                }
                status.innerHTML = statusText;
            }
        } else {
            faceDetected = false;
            stableFrames = 0;
            status.innerHTML = 'üëÅÔ∏è Seeking presence...';
        }
    });

    const cameraUtils = new Camera(video, {
        onFrame: async () => {
            await faceMesh.send({ image: video });
        },
        width: 640,
        height: 480
    });

    cameraUtils.start().catch(err => {
        status.innerHTML = '‚ö†Ô∏è Portal blocked: ' + err.message;
    });

    calibrateBtn.addEventListener('click', () => {
        if (faceDetected) {
            calibratedX = headX;
            calibratedY = headY;
            calibratedZ = headZ;
            calibratedPitch = headPitch;
            calibratedYaw = headYaw;
            autoCalibrated = true;
            stableFrames = 0;
            smoothCamX = 0;
            smoothCamY = 0;
            smoothCamZ = 0;
            status.innerHTML = '‚úÖ Re-attuned<br>Portal realigned';
        }
    });

    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.016;
        
        if (faceDetected && autoCalibrated) {
            updateCameraProjection();
        }
        
        scene.children.forEach(child => {
            if (child instanceof THREE.Mesh) {
                if (child.userData.type === 'glass') {
                    child.rotation.x += 0.003;
                    child.rotation.y += 0.005;
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'liquid') {
                    const i = child.userData.index;
                    const speedMult = 1 + proximityValue * 0.5 + (child.userData.gazeTime > 0 ? 0.5 : 0);
                    child.rotation.y += 0.01 * speedMult;
                    child.position.y = child.userData.basePos.y + Math.sin(time + i) * 2;
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'energy') {
                    const speedMult = 1 + proximityValue + (child.userData.gazeTime > 0 ? 1 : 0);
                    child.rotation.x += 0.01 * speedMult;
                    child.rotation.y += 0.015 * speedMult;
                    child.material.uniforms.time.value = time;
                }
            }
        });
        
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>

</body>
</html>
